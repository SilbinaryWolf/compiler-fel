/*test := 1 + 4 + 5
test = 5

if test == 5 {
	test = 6
	test = 5
}
*/

List :: struct {
	name: string = "listname"
}

Test :: struct {
	value: int
	derp: []string
	otherValue: string
	other: List
}

Complex :: struct {
	test: Test
}

meow := "test" + " hello"
meow += "me" + " wow"

test := 1 + 1
test += 2

myVal := Test{}
myVal.other.name = "nextlevel!"
myVal.other.name += " wooo!"
myVal.otherValue = "dweeeee"
myVal.other.name = "jeremy" + "woo" + myVal.other.name + myVal.other.name + meow


append :: (param1 string, param2 string) string {
	return param1 + "flew" + param2
}

// NOTE(Jake): 2018-01-03
//
// Need to decide if procedures can or cannot have side-effects, currently if you modify
// an object in a procedure, it stays modified.
//
testProc :: (param1 List) string {
	return param1.name+" append jeremy"+param1.name
	//param1.name = "blah" + param1.name
}

//myVal.otherValue = append("blest", "test")+append("meow", "test")

// todo(Jake): 2018-01-03
//
// Refactor so procedure calls / HTML elements use the same parsing code.
// Currently can't just call a procedure unless its in a set/declare statement.
//
t := testProc(



	myVal.other
	

	,

	"hey"

	)
latest := myVal.other.name + " woooo"

// NOTE(Jake): 2017-12-28, For some reason these values aren't emitting bytecode.
/*myVal.other = List{
	name: "Lol",
}
myVal.other.name = "nextlevel!"
myVal.derp []= "test"*/

/////////////////// TESTING BYTECODE ABOVE

Header :: css_config {
	.is-* {
		modify: false
	}
}

Header :: struct {
	isBlue: bool
}

Header :: css {
	.header {
		width: 100%
		height: 60px
		background-color: blue;
	}

	.header.is-active {
		display: block;
	}
}

Header :: html {
	class := "no_blue"
	if isBlue {
		// todo(Jake): Fix this, something wrong with evaluator not able to set a variable after declaring.
		// stuff BREAKS!
		// test
		class = "blue"
	}
	header(class="header "+class) {
	}
}
